import{e as x}from"./TechniqueType-CMl1wqtX.js";import{bS as M,iV as Ie,gL as te,bp as S,h as Le,i as ze,s as Ae}from"./main-CA1CST7A.js";import{b as E,l as W,c as V}from"./CIMSymbolHelper-BIh6RUM5.js";import{r as se}from"./rasterizingUtils-VXXiq7Os.js";import{o as G,w as De,G as Se}from"./enums-a_LDTPYU.js";import{o as re,N as Ee,x as j,d as Z,O as ke,f as q,F as X,y as Y,m as $,l as ie,s as Re,a as N,b as Be,t as Te,p as ae,u as Ce,T as Fe,k as Oe,S as oe,c as We,g as Ve,h as Ge,i as je,r as Ze,j as qe,A as ne,n as Xe,P as k,q as Ye,v as $e,w as Ne,z as Qe,B as He,C as Je,D as Ke,E as Ue,G as et,H as tt,I as st,J as rt,K as it,L as at,M as ot,Q as nt,R as ct,U as lt,V as ht,W as mt,X as dt,Y as ut,Z as pt}from"./PieChartMeshWriter-D1pMWnkt.js";import{t as R,a as B,s as ce}from"./definitions-MCCItX4r.js";import{c as ft}from"./constants-oLcGh8d3.js";import{c as _t}from"./libtess-u1DRmq2v.js";import{M as Q,i as le}from"./mat2d-BQA-1WB-.js";import{n as D}from"./mat2df32-fg3OHsAI.js";import{S as he,o as w,B as me,v as H,u as gt,l as de}from"./vec2-BnynUbeJ.js";import{r as T}from"./vec2f32-hTAvipMV.js";import{n as z}from"./vec2f64-CkowXrDb.js";import{d as yt,l as ue}from"./featureConversionUtils-DzHs61Do.js";import{e as J}from"./OptimizedGeometry-bNgqQoqZ.js";import{i as pe}from"./BoundingBox-DlCd_wcU.js";import{n as fe,r as Pt}from"./Utils-DTtCfAJt.js";import{d as xt}from"./ArcadeExpression-BuoNLmag.js";import{s as vt}from"./AttributeStore-CVgcDihV.js";function K(l){let{pixelDimensions:e,texelDimensions:r,baseSize:a,referenceSize:s,strokeWidth:t,sizeRatio:i}=l;if(e||(e=l.sprite.sdf?[0,0]:[l.sprite.width,l.sprite.height]),r||(r=l.sprite.sdf?[0,0]:e),l.patternHeight!=null){const n=l.patternHeight/e[1];e[1]*=n,e[0]*=n}a===-1&&(a=e[1]),a=M(a),s=M(s),t=M(t);const o=(l.sprite.sdfDecodeCoeff??1)*i;return{...l,pixelDimensions:e,texelDimensions:r,baseSize:a,referenceSize:s,strokeWidth:t,sdfDecodeCoeff:o}}const U=64,Mt=64,wt=2;let _e=class extends re{get vertexSpec(){return{createComputedParams:K,optionalAttributes:{zoomRange:N,value1Position2Value2:Re,lineLength:ie},attributes:{id:$,bitset:Y,pos:X,offset:q.marker,uv:ke.marker,animationPointerAndBaseSizeAndReferenceSize:Z,sizing:j,angle:Ee}}}_write(l,e){const r=this.evaluatedMeshParams.sprite,{textureBinding:a}=r;l.recordStart(this.instanceId,this.attributeLayout,a);const s=e.getDisplayId();if(this.shift&&e.geometryType==="esriGeometryPolyline")this._writeParticles(l,e);else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(l,e);else if(e.geometryType==="esriGeometryPolygon"){const t=e.readCentroidForDisplay();if(!t)return;const[i,o]=t.coords;this._writeQuad(l,s,i,o)}else if(e.geometryType==="esriGeometryPoint"){const t=e.readXForDisplay(),i=e.readYForDisplay();this._writeQuad(l,s,t,i)}else{const t=e.readGeometryForDisplay();t&&t.forEachVertex((i,o)=>{this._writeQuad(l,s,i,o)})}l.recordEnd()}_writePlacedMarkers(l,e){const r=E.fromFeatureSetReaderCIM(e)?.clone();if(!r)return;const a=-1,s=Be.getPlacement(r,a,this.evaluatedMeshParams.placement,M(1),l.id,Te());if(!s)return;const t=e.getDisplayId();let i=s.next(),o=null;for(;i!=null;){const n=i.tx,c=-i.ty;if(Math.abs(n)>se||Math.abs(c)>se){i=s.next();continue}const m=-i.getAngle();l.recordBounds(n,c,U,Mt),this.shift?o&&this._writeQuad(l,t,o[0],o[1],void 0,m):this._writeQuad(l,t,n,c,void 0,m),o=[n,c],i=s.next()}}_writeParticles(l,e){const r=e.getDisplayId(),a=e.readGeometryForDisplay();if(!a)return;const s=[];a.forEachVertex((c,m)=>{s.push([c,m])});const t=bt(s);let i=0;for(let c=1;c<s.length;c++){const m=s[c][0]-s[c-1][0],f=s[c][1]-s[c-1][1],h=Math.sqrt(m*m+f*f);i+=h}const o=c=>{for(const m of t){const{a:f,b:h}=m;this._writeQuad(l,r,f.position[0],f.position[1],[f.distance-c,h.position[0],h.position[1],h.distance-c],this.evaluatedMeshParams.angleToLine?Math.atan2(f.direction[1],f.direction[0]):0,i,!0)}},{placement:n}=this.evaluatedMeshParams;if(!n||"placementTemplate"in n||n.type==="CIMMarkerPlacementOnVertices"){let c;if(n&&n.type!=="CIMMarkerPlacementOnVertices")c=n.placementTemplate;else{c=[0];for(const f of t){const{a:h,b:d}=f,p=h.position[0]-d.position[0],u=h.position[1]-d.position[1],_=Math.sqrt(p*p+u*u);c.push(_)}}let m=-1*i;for(;m<(1+wt/2)*i;)for(const f of c)m+=f,o(m)}else n.type==="CIMMarkerPlacementAtExtremities"?n.extremityPlacement===G.JustBegin?o(1):n.extremityPlacement===G.JustEnd?(o(i-1),o(-1)):n.extremityPlacement===G.Both&&(o(1),o(i-1)):n.type==="CIMMarkerPlacementOnLine"&&o(i/2)}_writeQuad(l,e,r,a,s,t=0,i=0,o=!1){const n=this.evaluatedMeshParams.sprite,{rect:c}=n,m=c.x+R,f=c.y+R,h=c.x+c.width-R,d=c.y+c.height-R,p=l.vertexCount();o||l.recordBounds(r,a,U,U);const u={texXmin:m,texYmin:f,texXmax:h,texYmax:d,value1Position2Value2:s,angle:t/ft,lineLength:i};for(let _=0;_<4;_++)this._writeVertex(l,e,r,a,u);l.indexEnsureSize(6),l.indexWrite(p),l.indexWrite(p+1),l.indexWrite(p+2),l.indexWrite(p+1),l.indexWrite(p+3),l.indexWrite(p+2)}};function bt(l){const e=[];let r=0;for(let a=1;a<l.length;a++){const s=l[a-1],t=l[a],i=t[0]-s[0],o=t[1]-s[1],n=Math.sqrt(i*i+o*o),c=i/n,m=o/n;e.push({a:{position:s,distance:r,direction:[c,m]},b:{position:t,distance:r+n,direction:[c,m]}}),r+=n}return e}let It=class extends _e{constructor(){super(...arguments),this.shift=!1}},Lt=class extends _e{constructor(){super(...arguments),this.shift=!0}};class ge extends re{_write(e,r,a){const s=a??E.fromFeatureSetReaderCIM(r);if(!s)return;const t=this.evaluatedMeshParams.sprite,{textureBinding:i}=t;e.recordStart(this.instanceId,this.attributeLayout,i);const o=r.getDisplayId();this._writePoly(e,o,s.asOptimized()),e.recordEnd()}}let zt=class extends ge{constructor(){super(...arguments),this.vertexSpec={createComputedParams:K,attributes:{id:$,bitset:Y,pos:X,offset:q.fill,tlbr:oe,animationPointerAndBaseSizeAndReferenceSize:Z,sizing:j},optionalAttributes:{zoomRange:N,value1Position2Value2:ae,lineLength:Ze}}}_writePoly(l,e,r){const a=[];if(!qe(a,r))return;const s=l.vertexCount();r.forEachVertex((t,i)=>{this._writeVertex(l,e,t,i)}),l.indexEnsureSize(a.length);for(const t of a)l.indexWrite(s+t)}},At=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const ye=65535;class Dt extends ge{constructor(){super(...arguments),this.vertexSpec={createComputedParams:K,attributes:{id:$,bitset:Y,pos:X,offset:q.line,tlbr:oe,animationPointerAndBaseSizeAndReferenceSize:Z,sizing:j,accumulatedDistance:Oe,normal:Fe,segmentDirection:Ce},optionalAttributes:{zoomRange:N,value1Position2Value2:ae,lineLength:ie}},this._tessParams=new We,this._currentWrite=new At,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:ye,textured:!1},this._lineLength=0,this._lineTessellator=new _t((e,r,a,s,t,i,o,n,c,m,f)=>this._writeTesselatedVertex(e,r,a,s,t,i,o,n,c,m,f,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(e,r,a){const s=Ve(E.fromOptimized(a,"esriGeometryPolyline"),64);if(s==null)return;const{_currentWrite:t,_tessellationOptions:i}=this,{baseSize:o,capType:n,joinType:c,miterLimit:m}=this.evaluatedMeshParams,f=M(.5*o);i.halfWidth=f,i.capType=Ge(n||De.Round),i.joinType=je(c||Se.Round),i.miterLimit=m||2,t.out=e,t.id=r,t.vertexCount=0,t.indexCount=0,t.vertexFrom=e.vertexCount(),t.vertexBounds=1;for(const{line:h,start:d,pathLength:p}of s){i.initialDistance=d%ye,t.pathLength=p,this._lineLength=0;for(let u=1;u<h.length;u++){const _=h[u].x-h[u-1].x,g=h[u].y-h[u-1].y;this._lineLength+=Math.sqrt(_*_+g*g)}this._lineTessellator.tessellate(h,i,!1)}}_writeTesselatedVertex(e,r,a,s,t,i,o,n,c,m,f,h){const{out:d,id:p,vertexBounds:u,pathLength:_}=this._currentWrite;return this.hasEffects&&d.recordBounds(e,r,u,u),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=n,this._tessParams.normalX=c,this._tessParams.normalY=m,this._tessParams.directionX=t,this._tessParams.directionY=i,this._tessParams.distance=f,this._tessParams.pathLength=_,this._tessParams.lineLength=h,this._writeVertex(d,p,e,r,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,r,a){const{out:s}=this._currentWrite;s.indexEnsureSize(3),s.indexWrite(e),s.indexWrite(r),s.indexWrite(a),this._currentWrite.indexCount+=3}}const C=1,A=0,St=128;function Et(l,e,r){return te(`${l}${e}${r}`)}function kt(l,e,r,a,s){return te(`${l}${s}${e}${r*2**(k-a)}`)}const Rt=Ie(l=>{let e=0;if(l===0)return 1/0;for(;!(l%2);)e++,l/=2;return e});class Bt extends ne{constructor(){super(...arguments),this._zoomLevel=0}_write(e,r,a,s){if(this._zoomLevel=s||0,a!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(r.geometryType){case"esriGeometryPoint":{const t=r.readXForDisplay(),i=r.readYForDisplay();this._writePoint(e,t,i,0,r);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const t=r.readCentroidForDisplay();if(!t)return;const[i,o]=t.coords;this._writePoint(e,i,o,0,r);break}case"esriGeometryMultipoint":{let t=0;const i=E.fromFeatureSetReader(r);if(i?.nextPath())for(;i.nextPoint();)this._writePoint(e,i.x,i.y,t++,r);break}case"esriGeometryPolyline":this._writeLines(e,r)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:r}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,r==="middle"?0:r==="bottom"?-1:1]}_createLineLabelMetric(e,r,a,s,t){const[i,o]=this._getMetricDir(),n=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0,m=this.evaluatedMeshParams.labelClassId;return new fe(e,m,r,a,s,i,o,n,c,t)}_writePoint(e,r,a,s,t){if(r<0||r>B||a<0||a>B)return;const i=this._getShaping();if(!i)return;const o=t.getDisplayId(),n=this.evaluatedMeshParams.labelClassId,c=Et(t.getObjectId(),n,s),[m,f]=this._getMetricDir(),h=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0,p=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new fe(o,n,c,r,a,m,f,h,d,p)),this._writeGlyphs(e,o,r,a,i,0,p,void 0,!1),e.metricBoxWrite(i.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const r=e.getBoundsInfo();if(r)return r}return null}_writeLines(e,r){const{scaleInfo:a,verticalAlignment:s}=this.evaluatedMeshParams,t=this.evaluatedMeshParams.repeatLabelDistance||128,i=this._getShaping("middle");if(!i)return;const o=(c,m,f,h)=>this._placeSubdivGlyphs(c,m,f,h),n=(i.bounds.width+t)/(1<<C);this._current={out:e,id:r.getDisplayId(),objId:r.getObjectId(),shaping:i,zoomRange:Xe(a,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=s==="bottom"?"above":s==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(r,o,n):this._writeCenterAlong(r,o,n)}_writeAboveAndBelowAlong(e,r,a){const{repeatLabel:s}=this.evaluatedMeshParams,{shaping:t}=this._current,i=t.bounds.halfHeight,o=e.readGeometryForDisplay();if(!o)return;const n=new J;yt(n,o,!1,!1,"esriGeometryPolyline",1);const c=Pe(new J,n,i),m=Pe(new J,n,-i),f=ue(m,"esriGeometryPolyline",!1,!1),h=ue(c,"esriGeometryPolyline",!1,!1),d=W(h.paths,t.bounds.width),p=W(f.paths,t.bounds.width);this._current.offsetDirection="above";for(let u=0;u<d.length;u++)this._current.pathIndex=u,V(d[u],a,r,!!s);this._current.offsetDirection="below";for(let u=0;u<p.length;u++)this._current.pathIndex=u,V(p[u],a,r,!!s)}_writeCenterAlong(e,r,a){const{repeatLabel:s}=this.evaluatedMeshParams,{shaping:t}=this._current,i=W(e.readLegacyGeometryForDisplay().paths,t.bounds.width);for(let o=0;o<i.length;o++)this._current.pathIndex=o,V(i[o],a,r,!!s)}_placeSubdivGlyphs(e,r,a,s){const{allowOverrun:t,labelPosition:i,repeatLabelDistance:o}=this.evaluatedMeshParams,n=this._current.zoomRange[0],c=Rt(r),m=this._current.shaping.bounds.width/(1<<C),f=Math.sqrt(o||St)/(1<<C),h=Math.min(a,s-a),d=this._current.shaping.isMultiline?k:Math.log2(h/(f+m/2)),p=r===0?d:Math.min(c,d),u=Math.max(n,this._zoomLevel+C-p),_=this._zoomLevel-u,g=this._current.shaping.bounds.width/2*2**_,y=kt(this._current.objId,this._current.pathIndex,r,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?r===0&&this._placeStraight(e,u,y):t&&_<0?this._placeStraightAlong(e,n,y):i==="parallel"?this._placeStraightAlong(e,u,y):i==="curved"&&this._placeCurved(e,u,g,y)}_placeStraight(e,r,a){const{out:s,id:t,shaping:i,referenceBounds:o}=this._current,{x:n,y:c}=e;s.metricStart(this._createLineLabelMetric(t,a,n,c)),s.metricBoxWrite(i.boundsT);const m=e.angle*(180/Math.PI)%360,f=(e.angle*(180/Math.PI)+180)%360,h={clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:r};this._writeGlyphs(s,t,n,c,i,0,o,h,!1);const d={clipAngle:f,mapAligned:!0,isLineLabel:!0,minZoom:r};this._writeGlyphs(s,t,n,c,i,0,o,d,!1),s.metricEnd()}_placeCurved(e,r,a,s){const{out:t,id:i}=this._current;t.metricStart(this._createLineLabelMetric(i,s,e.x,e.y));const o=e.clone(),n=e.angle*(180/Math.PI)%360,c=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(o,r,1,n),this._placeBack(e,o,r,a,1,n),this._placeForward(e,o,r,a,1,n)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(o,r,0,c),this._placeBack(e,o,r,a,0,c),this._placeForward(e,o,r,a,0,c)),t.metricEnd()}_placeStraightAlong(e,r,a){const{out:s,id:t,shaping:i,zoomRange:o,referenceBounds:n}=this._current,{boxBorderLineColor:c,boxBackgroundColor:m}=this.evaluatedMeshParams,f=e.clone(),h=e.angle*(180/Math.PI)%360,d=(e.angle*(180/Math.PI)+180)%360,p=i.glyphs.length>0&&!(!c&&!m);if(s.metricStart(this._createLineLabelMetric(t,a,e.x,e.y)),p){const u=Math.max(r,o[0],0),_=Math.min(k,o[1]),g=Q(D(),-e.angle),y={minZoom:u,maxZoom:_,clipAngle:h,mapAligned:!0,isLineLabel:!0},v=M(this.evaluatedMeshParams.offsetX),P=M(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const b=T(v,-1*P),[I,L]=i.shapeBackground(le(D(),g,b));s.recordStart(this.instanceId,this.attributeLayout,i.glyphs[0].textureBinding),this._writeTextBox(s,t,e.x,e.y,L,n,y),s.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const b=T(v,P),[I,L]=i.shapeBackground(le(D(),g,b));y.clipAngle=d,s.recordStart(this.instanceId,this.attributeLayout,i.glyphs[0].textureBinding),this._writeTextBox(s,t,e.x,e.y,L,n,y),s.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(f,r,1,h,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(f,r,0,d,!0),s.metricEnd()}_placeBack(e,r,a,s,t,i){const o=e.clone();let n=e.backwardLength+A;for(;o.prev()&&!(n>=s);)this._placeOnSegment(o,r,n,a,-1,t,i),n+=o.length+A}_placeForward(e,r,a,s,t,i){const o=e.clone();let n=e.remainingLength+A;for(;o.next()&&!(n>=s);)this._placeOnSegment(o,r,n,a,1,t,i),n+=o.length+A}_placeFirst(e,r,a,s,t=!1){const{out:i,id:o,shaping:n,zoomRange:c,referenceBounds:m}=this._current,f=n.glyphs,h=M(this.evaluatedMeshParams.offsetX),d=M(this.evaluatedMeshParams.offsetY),p=T(h,d),u=Q(D(),-e.angle);he(p,p,u);for(const _ of f){const g=_.x>n.bounds.x?a:1-a,y=g*e.remainingLength+(1-g)*e.backwardLength,v=Math.abs(_.x+_.width/2-n.bounds.x),P=Math.max(0,this._zoomLevel+Math.log2(v/(y+A))),b=Math.max(r,t?0:P);if(_.maxZoom=Math.min(c[1],k),_.angle=e.angle+(1-a)*Math.PI,_.minZoom=Math.max(c[0],b),this._writeLineGlyph(i,o,e.x,e.y,_,s,m,!0),(a||this._current.offsetDirection)&&this._isVisible(_.minZoom,_.maxZoom)){const I=new pe(_.bounds.x+p[0],_.bounds.y+p[1],_.bounds.width,_.bounds.height);i.metricBoxWrite(I)}}}_placeOnSegment(e,r,a,s,t,i,o){const{out:n,id:c,shaping:m,referenceBounds:f}=this._current,h=m.glyphs,d=e.dx/e.length,p=e.dy/e.length,u={x:e.x+a*-t*d,y:e.y+a*-t*p},_=M(this.evaluatedMeshParams.offsetX),g=M(this.evaluatedMeshParams.offsetY),y=T(_,g),v=Q(D(),-e.angle);he(y,y,v);for(const P of h){const b=P.x>m.bounds.x?i:1-i;if(!(b&&t===1||!b&&t===-1))continue;const I=Math.abs(P.x+P.width/2-m.bounds.x),L=Math.max(0,this._zoomLevel+Math.log2(I/a)-.1),we=Math.max(s,this._zoomLevel+Math.log2(I/(a+e.length+A)));if(L!==0&&(P.angle=e.angle+(1-i)*Math.PI,P.minZoom=we,P.maxZoom=L,this._writeLineGlyph(n,c,u.x,u.y,P,o,f,!0),(i||this._current.offsetDirection)&&this._isVisible(P.minZoom,P.maxZoom))){const be=new pe(P.bounds.x+y[0],P.bounds.y+y[1],P.bounds.width,P.bounds.height);n.metricBoxWrite(be)}}}_writeLineGlyph(e,r,a,s,t,i,o,n){if(a<0||a>B||s<0||s>B)return;e.recordStart(this.instanceId,this.attributeLayout,t.textureBinding);const{texcoords:c,offsets:m}=t,{fontSize:f,haloSize:h,outlineSize:d}=this._textMeshTransformProps;this._writeQuad(e,r,a,s,{texcoords:c,offsets:m,fontSize:f,haloSize:h,outlineSize:d,color:Ye(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:o,minZoom:Math.max(this._current.zoomRange[0],t.minZoom),maxZoom:Math.min(this._current.zoomRange[1],t.maxZoom),clipAngle:i,mapAligned:n,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*ce)/ce}_isVisible(e,r){let a=Math.max(this._current.zoomRange[0],e),s=Math.min(this._current.zoomRange[1],r);a=this._packedZoom(a),s=this._packedZoom(s);const t=this._packedZoom(this._zoomLevel);return a<=t&&t<=s}}function Pe(l,e,r){const{coords:a,lengths:s}=e,t=z(),i=z(),o=z(),n=z(),c=z(),m=z(),f=2;let h=0;for(let d=0;d<s.length;d++){const p=s[d];for(let u=0;u<p;u++){const _=f*(u+h-1),g=f*(u+h),y=f*(u+h+1);u>0?w(t,a[_],a[_+1]):w(t,0,0),w(i,a[g],a[g+1]),u<p-1?w(o,a[y],a[y+1]):w(o,0,0),u===0?w(n,0,0):(me(n,i,t),H(n,n),w(n,n[1],-n[0])),u===p-1?w(c,0,0):(me(c,o,i),H(c,c),w(c,c[1],-c[0])),gt(m,n,c),H(m,m);const v=m[0]*c[0]+m[1]*c[1];v!==0&&de(m,m,v),de(m,m,r),l.coords.push(i[0]+m[0],i[1]+m[1])}l.lengths.push(p),h+=p}return l}class xe extends vt{constructor(e){super(),this._value=e}resize(e){}read(e,r){return this._value}readWithDefault(e,r,a){return this._value}hasArcadeDependency(e){return!1}}const Tt=()=>ze.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function F(l,e,r,a){const{defaultValue:s,valueExpressionInfo:t,value:i}=e;if(t){if(t.type==="dictionary-template")return{...e,computed:l.createDictionaryTemplateField(t,r),defaultValue:s};const{expression:o}=t,n=await l.createComputedField({expression:o},a);return n?{...e,computed:n,defaultValue:s}:null}return{...e,computed:new xe(i),defaultValue:s}}async function ve(l,e,r){const{valueExpressionInfo:a}=e,s=a.type==="dictionary-template"?l.createDictionaryTemplateField(a,r):await l.createComputedField({expression:a.expression});return s?{...e,computed:s}:null}function Me(l){return typeof l=="object"&&l!=null&&(!(!("valueExpressionInfo"in l)||!l.valueExpressionInfo)||"type"in l&&l.type==="Process"&&"op"in l&&l.op==="Random")}function O(l){if(Array.isArray(l)){for(const e of l)if(O(e))return!0}if(typeof l=="object"){if(Me(l))return!0;for(const e in l)if(O(l[e]))return!0}return!1}class ee{static async create(e,r,a,s){const t={},i=new Map,o=new Map,n=new Map,c=new Map,m=new Map,f=new Map;for(const h in a){const d=a[h];if(d!=null&&typeof d=="object")if(Array.isArray(d)){if(typeof d[0]=="object")throw new Error(`InternalError: Cannot handle ${h}. Nested array params are not supported`);t[h]=d}else if("valueExpressionInfo"in d){if(d.value){t[h]=d.value;continue}const p=await ve(e,d,s);if(!p){t[h]=d.defaultValue;continue}i.set(h,p),t[h]=null}else switch(d.type){case"cim-effect-infos":if(d.effectInfos.some(p=>p.overrides.length)){o.set(h,{effects:await Promise.all(d.effectInfos.map(async p=>{const u=p.overrides.map(_=>F(e,_,s,!1));return{effect:p.effect,compiledOverrides:(await Promise.all(u)).filter(S)}}))});break}t[h]=d.effectInfos.map(p=>p.effect);break;case"cim-marker-placement-param":d.overrides.length&&n.set(h,{placementInfo:d,compiledOverrides:(await Promise.all(d.overrides.map(p=>F(e,p,s,!1)))).filter(S)}),t[h]=d.placement;break;case"text-rasterization-param":{if(d.overrides.length){const u=d.overrides.map(_=>F(e,_,s,d.useLegacyLabelEvaluationRules??!1));c.set(h,{compiledOverrides:(await Promise.all(u)).filter(S),rasterizationParam:d,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:d.resource};t[h]=await r.fetchResourceImmediate(p)??null;break}case"sprite-rasterization-param":{if(d.overrides.length){const u=d.overrides.map(_=>F(e,_,s,!1));c.set(h,{compiledOverrides:(await Promise.all(u)).filter(S),rasterizationParam:d,objectIdToResourceId:new Map});continue}if(d.resource.type==="animated"){c.set(h,{compiledOverrides:[],rasterizationParam:d,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:d.resource};t[h]=await r.fetchResourceImmediate(p)??null;break}case"cim-marker-transform-param":{const{params:p}=d;if(O(p)){const u={compiledMarkerInfos:[]};await Promise.all(p.map(async _=>{const g={props:{}};for(const y in _)if(Me(_[y])){const v=await ve(e,_[y],s);g.compiledExpressionMap||(g.compiledExpressionMap=new Map);const P=g.compiledExpressionMap;v&&P.set(y,v)}else g.props[y]=_[y];u.compiledMarkerInfos.push(g)})),m.set(h,u)}else t[h]={type:"cim-marker-transform-info",infos:p};break}case"animation-params":{const{params:p}=d,u=$e(p);if(O(u)){const _=await Promise.all(u.map(g=>Ne(g,e)));f.set(h,{params:_,propertyIdToResourceId:new Map,key:h})}else{const _=Qe(u),g=await r.fetchResourceImmediate({type:"animation-info",resource:_});g!=null&&g.type==="sprite"&&(t[h]={dataRow:g.rect.y,dataColumn:g.rect.x})}break}default:t[h]=d}else t[h]=d}return new ee(a,t,i,o,n,c,m,f)}constructor(e,r,a,s,t,i,o,n){this.inputMeshParams=e,this._resolvedMeshParams=r,this._dynamicProperties=a,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=t,this._dynamicAsyncProperties=i,this._dynamicTransformProperties=o,this._dynamicAsyncAnimations=n,this.evaluator=c=>c,this._arcadeDependencies=new Set;for(const c of this._expressions())xt(this._arcadeDependencies,c)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,r,a){for(const s of this._dynamicAsyncProperties.values()){const t=Le(s.rasterizationParam.resource);s.rasterizationParam.resource.type==="animated"&&s.rasterizationParam.resource.randomizeStartTime&&(t.primitiveName="__RESERVED__PRIMITIVE__NAME__",t.startGroup=He(r.getObjectId()||0));for(const{primitiveName:o,propertyName:n,computed:c,defaultValue:m,valueExpressionInfo:f}of s.compiledOverrides)try{const h=s.rasterizationParam.resource.type==="animated"?t.primitiveName:o;Pt(t,h,n,c,r,a,m)}catch(h){Tt().errorOnce(new Ae("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:h,valueExpressionInfo:f}))}const i=e.enqueueRequest({type:"cim-rasterization-info",resource:t});s.objectIdToResourceId.set(r.getObjectId(),i)}for(const s of this._dynamicAsyncAnimations.values()){const t=s.params.map(n=>Je(n,r,a)).map(Ke).map(n=>n.simplify()),i=Ue(t),o=e.enqueueRequest({type:"animation-info",resource:i});s.propertyIdToResourceId.set(r.getObjectId()+"."+s.key,o)}}evaluateMeshParams(e,r,a){for(const[s,t]of this._dynamicProperties.entries())this._resolvedMeshParams[s]=t.computed.readWithDefault(r,a,t.defaultValue);for(const[s,t]of this._dynamicPlacementProperties.entries())for(const{computed:i,defaultValue:o,propertyName:n}of t.compiledOverrides){const c=i.readWithDefault(r,a,o);t.placementInfo.placement[n]=c,this._resolvedMeshParams[s]=t.placementInfo.placement}for(const[s,t]of this._dynamicEffectProperties.entries())for(const i of t.effects){for(const{computed:o,defaultValue:n,propertyName:c}of i.compiledOverrides){const m=o.readWithDefault(r,a,n);i.effect[c]=m}this._resolvedMeshParams[s]=t.effects.map(o=>o.effect)}for(const[s,t]of this._dynamicTransformProperties.entries()){const i={type:"cim-marker-transform-info",infos:[]};for(const o of t.compiledMarkerInfos){const n={...o.props};if(o.compiledExpressionMap)for(const[c,m]of o.compiledExpressionMap){const f=m.computed.readWithDefault(r,a,m.defaultValue);n[c]=typeof f=="number"||typeof f=="boolean"?f:m.defaultValue}i.infos.push(n)}this._resolvedMeshParams[s]=i}for(const[s,t]of this._dynamicAsyncProperties.entries()){const i=t.objectIdToResourceId.get(r.getObjectId());if(i==null)continue;const o=e.getResource(i);this._resolvedMeshParams[s]=o}for(const[s,t]of this._dynamicAsyncAnimations.entries()){const i=t.propertyIdToResourceId.get(r.getObjectId()+"."+s);if(i==null)continue;const o=e.getResource(i);this._resolvedMeshParams[s]={dataRow:o.rect.y,dataColumn:o.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const r of e.effects)for(const a of r.compiledOverrides)yield a.computed;for(const e of this._dynamicPlacementProperties.values())for(const r of e.compiledOverrides)yield r.computed;for(const e of this._dynamicAsyncProperties.values())for(const r of e.compiledOverrides)yield r.computed;for(const e of this._dynamicTransformProperties.values())for(const r of e.compiledMarkerInfos)if(r.compiledExpressionMap!=null)for(const a of r.compiledExpressionMap.values())yield a.computed;for(const e of this._dynamicAsyncAnimations.values())for(const r of e.params)yield*et(r)}}class Ct{async createMeshWriter(e,r,a,s,t){const i=this._getMeshWriter(s.techniqueType),o=await ee.create(e,r,s.inputParams,t),n=new i(s.id,o,s.optionalAttributes,a);return await n.loadDependencies(),n}_getMeshWriter(e){switch(e){case x.Fill:return pt;case x.DotDensity:return ut;case x.ComplexFill:return dt;case x.PatternFill:return mt;case x.GradientFill:return ht;case x.OutlineFill:return lt;case x.PatternOutlineFill:return ct;case x.ComplexOutlineFill:return nt;case x.Marker:return ot;case x.PieChart:return at;case x.Text:return ne;case x.Line:return it;case x.TexturedLine:return rt;case x.GradientStroke:return st;case x.Heatmap:return tt;case x.Label:return Bt;case x.AnimatedMarker:return It;case x.AnimatedMarkerShift:return Lt;case x.AnimatedFill:return zt;case x.AnimatedLine:return Dt;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{xe as r,Ct as y};
